#!/usr/bin/env python

import os
import sys
import time
import collections
from argparse import ArgumentParser

parser = ArgumentParser(description = 'Update subscriptions.')
parser.add_argument('--config', '-c', metavar = 'CONFIG', dest = 'config', help = 'Configuration JSON.')

args = parser.parse_args()
sys.argv = []

## Load the configuration
from dynamo.dataformat.configuration import Configuration

config = Configuration(args.config)

## Set up logging (write to stdout & stderr)
from dynamo.core.executable import make_standard_logger, read_only, inventory

LOG = make_standard_logger(config.get('log_level', 'info'))

## Set up a handle to the RLFSM
from dynamo.fileop.rlfsm import RLFSM

rlfsm = RLFSM(config.get('rlfsm', None))

if read_only:
    rlfsm.set_read_only()

## Set up a handle to the registry
from dynamo.registry.registry import RegistryDatabase

registry = RegistryDatabase()

## Run
from dynamo.dataformat import Block, BlockReplica, File

LOG.info('Updating the inventory from injections.')

processed_injection_ids = []

# Since we allow asynchronous injections, if two processes write new files belonging to a same block sequentially, we can end up with two
# lines for a block with inconsistent attributes. We need to pool the blocks and files here and resolve conflicts.
block_changes = collections.defaultdict(list)
replica_changes_by_block = collections.defaultdict(lambda: collections.defaultdict(list))
file_changes_by_block = collections.defaultdict(lambda: collections.defaultdict(list))

n_injected = 0
n_deleted = 0

for iid, cmd, objstr in registry.db.xquery('SELECT `id`, `cmd`, `obj` FROM `data_injections` ORDER BY `id`'):
    processed_injection_ids.append(iid)

    obj = inventory.make_object(objstr)

    if type(obj) is Block:
        block_changes[obj.full_name()].append((cmd, obj))
    
    elif type(obj) is BlockReplica:
        # obj.block and obj.site are the block full name and site name
        replica_changes_by_block[obj.block][obj.site].append((cmd, obj))

    elif type(obj) is File:
        # obj.block is the block full name
        file_changes_by_block[obj.block][obj.lfn].append((cmd, obj))

    elif cmd == 'update':
        inventory.update(obj)
        n_injected += 1

    elif cmd == 'delete':
        inventory.delete(obj)
        n_deleted += 1

# Update block and file data
for block_full_name, changes in block_changes.iteritems():
    dataset_name, block_name = Block.from_full_name(block_full_name)
    # dataset must exist
    dataset = inventory.datasets[dataset_name]
    block = dataset.find_block(block_name)

    if block_full_name in file_changes_by_block:
        files = file_changes_by_block[block_full_name]
    else:
        files = None

    new_files = []

    if block is None:
        # new block
        if changes[-1][0] == 'delete':
            # going to be deleted in the end
            continue

        obj = changes[-1][1]

        if files is not None:
            # use the files list to construct the size and nfiles attribute. Use the last update for the rest.
            obj.num_files = 0
            obj.size = 0
            for lfn, file_changes in files.iteritems():
                if file_changes[-1][0] == 'update':
                    obj.num_files += 1
                    obj.size += file_changes[-1][1].size

            block = inventory.update(obj)
            n_injected += 1

            for lfn, file_changes in files.iteritems():
                if file_changes[-1][0] == 'update':
                    new_files.append(inventory.update(file_changes[-1][1]))
                    n_injected += 1

        else:
            if obj.num_files != 0 or obj.size != 0:
                raise RuntimeError('New block %s created with finite size without new files' % block_full_name)

            block = inventory.update(obj)
            n_injected += 1

    else:
        # existing block
        if changes[-1][0] == 'delete':
            inventory.delete(block)
            n_deleted += 1
            continue

        obj = changes[-1][1]

        block.is_open = obj.is_open
        block.last_update = obj.last_update

        if files is not None:
            # use the files list to construct the size and nfiles attribute.
            for lfn, file_changes in files.iteritems():
                injected_file = file_changes[-1][1]
                lfile = block.find_file(lfn)

                if file_changes[-1][0] == 'update':
                    if lfile is None:
                        # file size cannot change; if lfile is not None, we do nothing.
                        block.num_files += 1
                        block.size += injected_file.size
                        new_files.append(inventory.update(injected_file)) # adds the file to the block
                        n_injected += 1

                else:
                    if lfile is not None:
                        block.num_files -= 1
                        block.size -= file_changes[-1][1].size
                        inventory.delete(injected_file) # deletes the file from the block
                        n_deleted += 1

        inventory.register_update(block)
        n_injected += 1

    if block_full_name in replica_changes_by_block:
        for site_name, replica_changes in replica_changes_by_block[block_full_name].iteritems():
            # site must exist
            site = inventory.sites[site_name]

            replica = block.find_replica(site)

            if replica is None:
                if replica_changes[-1][0] == 'delete':
                    pass
                else:
                    inventory.update(replica_changes[-1][1])
                    n_injected += 1

            else:
                if replica_changes[-1][0] == 'delete':
                    inventory.delete(replica)
                    n_deleted += 1
                else:
                    inventory.update(replica_changes[-1][1])
                    n_injected += 1

    for lfile in new_files:
        for replica in block.replicas:
            if not replica.has_file(lfile):
                rlfsm.subscribe_file(replica.site, lfile)

LOG.info('Injected %d objects and deleted %d objects.', n_injected, n_deleted)

LOG.info('Converting pre-subscriptions to subscriptions.')

rlfsm.convert_pre_subscriptions(inventory)

LOG.info('Updating the inventory from transfers and deletions.')

subscriptions = rlfsm.get_subscriptions(inventory)

by_replica = {}
replicas_to_update = set()
done_ids = []

for sub in subscriptions:
    if type(sub) is RLFSM.Subscription:
        optype = 'transfer'
    else:
        optype = 'deletion'

    LOG.debug('Subscription entry: %d, %s, %s, %s, %s', sub.id, sub.status, optype, sub.file.lfn, sub.destination.name)

    replica = sub.file.block.find_replica(sub.destination)

    if replica is None:
        # unexpected file! -> mark the subscription for deletion and move on
        if status == 'done':
            done_ids.append(sub.id)
            continue

    try:
        file_ids, projected = by_replica[replica]
    except KeyError:
        file_ids, projected = by_replica[replica] = (set(), set())

        if replica.file_ids is None:
            # this replica is already full
            file_ids = set(f.id for f in replica.block.files)
        else:
            file_ids = set(replica.file_ids)
        
    if type(sub) is RLFSM.Subscription:
        if sub.status == 'done':
            file_ids.add(sub.file.id)
        elif sub.status != 'cancelled':
            projected.add(sub.file.id)

    else:
        if sub.status != 'cancelled':
            try:
                projected.remove(sub.file.id)
            except KeyError:
                pass

        if sub.status == 'done':
            try:
                file_ids.remove(sub.file.id)
            except KeyError:
                pass

    if sub.status == 'done':
        replicas_to_update.add(replica)
        done_ids.append(sub.id)

for replica in replicas_to_update:
    file_ids, projected = by_replica[replica]

    n_projected = len(projected)

    LOG.debug('Updating replica %s with file_ids %s projected %d', replica, file_ids, n_projected)

    if len(file_ids) == 0 and n_projected == 0:
        LOG.debug('Deleting')
        inventory.delete(replica)
    else:
        all_files = replica.block.files
        full_file_ids = set(f.id for f in all_files)

        if file_ids == full_file_ids:
            LOG.debug('Replica is full. Updating')
            replica.file_ids = None
            replica.size = sum(f.size for f in all_files)
            replica.last_update = int(time.time())
            inventory.register_update(replica)
        else:
            if replica.file_ids is None:
                existing_file_ids = full_file_ids
            else:
                existing_file_ids = set(replica.file_ids)

            if file_ids != existing_file_ids:
                LOG.debug('Replica content has changed: existing %s, new %s', existing_file_ids, file_ids)
                replica.file_ids = tuple(file_ids)
                replica.size = sum(f.size for f in all_files if f.id in file_ids)
                replica.last_update = int(time.time())
                inventory.register_update(replica)

# Remove injections and subscriptions
# This is dangerous though - if inventory update fails on the server side for some reason,
# we might not see the inconsistency for a while.

if not read_only:
    registry.db.lock_tables(write = ['data_injections'])
    registry.db.delete_many('data_injections', 'id', processed_injection_ids)

    if registry.db.query('SELECT COUNT(*) FROM `data_injections`')[0] == 0:
        registry.db.query('ALTER TABLE `data_injections` AUTO_INCREMENT = 1')

    registry.db.unlock_tables()

rlfsm.close_subscriptions(done_ids)

LOG.info('Inventory update completed.')
