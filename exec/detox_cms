#!/usr/bin/env python

import sys
import os
import re
import logging
import fnmatch

from argparse import ArgumentParser

parser = ArgumentParser(description = 'Detox')
parser.add_argument('--policy', '-p', metavar = 'FILE', dest = 'policy', required = True, help = 'Policy files.')
parser.add_argument('--config', '-c', metavar = 'CONFIG', dest = 'config', required = True, help = 'Configuration JSON.')
parser.add_argument('--comment', '-m', metavar = 'COMMENT', dest = 'comment', help = 'Comment to be sent to deletion interface as well as the local deletion record.')
parser.add_argument('--snapshot-run', '-N', action = 'store_true', dest = 'snapshot_run', help = 'Do not make any actual deletion requests or changes to inventory. Create no cycle, but save the results in the snapshot cache.')
parser.add_argument('--test-run', '-T', action = 'store_true', dest = 'test_run', help = 'Do not make any actual deletion requests or changes to inventory. Create a new cycle.')

args = parser.parse_args()
sys.argv = []

if args.snapshot_run and args.test_run:
    sys.stderr.write('--snapshot-run and --test-run cannot be set at the same time.')
    sys.exit(1)

## TODO snapshot_run is currently not implemented

## Load the configuration
from dataformat.configuration import Configuration

config = Configuration(args.config)

## Set up logging (write to stdout)
log_level = getattr(logging, config.log_level.upper())
log_format = '%(asctime)s:%(levelname)s:%(name)s: %(message)s'

logging.basicConfig(level = log_level, format = log_format, stream = sys.stdout)
LOG = logging.getLogger()

## Run the main detox object
from detox.main import Detox
from core.executable import inventory

LOG.info('Starting Detox.')

config.detox.deletion_op.config.phedex = config.phedex
config.detox.copy_op.config.phedex = config.phedex
if args.snapshot_run or args.test_run:
    config.detox.history.test = True
    config.detox.deletion_op.config.dry_run = True
    config.detox.copy_op.config.dry_run = True

with open(os.environ['DYNAMO_BASE'] + '/etc/policies.tag') as tag:
    policy_version = tag.read().strip()

config.detox.policy_file = args.policy
config.detox.policy_version = policy_version

## Temporary - translate all web locks into mysql locks
from demand import WebReplicaLock
from core.executable import registry
from utils.interface.webservice import POST

LOG.info('Translating web-based replica locks into DB-based locks.')

expiry = '2018-02-28'
comment = 'Auto-produced by dynamo'

demand_conf = config.detox.demand

# save original users    
mysqllock_users = demand_conf.MySQLReplicaLock.users
demand_conf.MySQLReplicaLock.users = []

# we process one source at a time, because each source registers mysql locks as a different user
weblock_conf = demand_conf.WebReplicaLock
for name, source_conf in weblock_conf.sources.items():
    instance_conf = Configuration({'sources': {name: source_conf.clone()}, 'auth': weblock_conf.auth})
    if args.test_run:
        # don't block for lock of locks
        try:
            instance_conf.sources[name].pop('lock_url')
        except KeyError:
            pass

    weblock = WebReplicaLock(instance_conf)
    weblock.update(inventory)

    data = []
    
    for dataset in inventory.datasets.itervalues():
        try:
            locked_blocks = dataset.demand['locked_blocks']
        except KeyError:
            # weblock did not create any lock for this dataset
            continue
    
        entries = []
    
        # if the lock applies to all sites and all blocks of this dataset, we just make one global lock
        collapse_dataset = True
        locked_sites = set()

        for site, blocks in locked_blocks.iteritems():
            locked_sites.add(site)

            replica = site.find_dataset_replica(dataset)
    
            if blocks == set(br.block for br in replica.block_replicas):
                entries.append({'item': dataset.name, 'sites': site.name, 'expires': expiry, 'comment': comment})
            else:
                for block in blocks:
                    entries.append({'item': dataset.name + '#' + block.real_name(), 'sites': site.name, 'expires': expiry, 'comment': comment})
    
                collapse_dataset = False

        if locked_sites != set(r.site for r in dataset.replicas):
            collapse_dataset = False
    
        if collapse_dataset:
            # replace entries with a single-element list
            entries = [{'item': dataset.name, 'expires': expiry, 'comment': comment}]
    
        data.extend(entries)
    
        dataset.demand.pop('locked_blocks')

    if not args.test_run:
        request_url = 'detoxlock/set?asuser=%s&service=%s' % (source_conf.user, source_conf.service)
        registry.frontend.make_request(request_url, method = POST, options = data, format = 'json')

demand_conf.MySQLReplicaLock.users = mysqllock_users

detox = Detox(config.detox)
detox.run(inventory, comment = args.comment)

## If test run, don't send back the inventory updates
if args.test_run:
    inventory.clear_update()
