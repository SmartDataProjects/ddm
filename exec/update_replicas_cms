#!/usr/bin/env python

import sys
import logging
import time
from argparse import ArgumentParser

parser = ArgumentParser(description = 'Dynamo')
parser.add_argument('--config', '-c', metavar = 'CONFIG', dest = 'config', default = '', help = 'Configuration JSON.')
parser.add_argument('--log-level', '-l', metavar = 'LEVEL', dest = 'log_level', default = 'INFO', help = 'Logging level.')

args = parser.parse_args()
sys.argv = []

## Set up logging (write to stderr unless path is given)
log_level = getattr(logging, args.log_level.upper())
log_format = '%(asctime)s:%(levelname)s:%(name)s: %(message)s'

LOG = logging.getLogger()
LOG.setLevel(log_level)
log_handler = logging.StreamHandler()
log_handler.setFormatter(logging.Formatter(fmt = log_format))
LOG.addHandler(log_handler)

## Load and initialize sources

from dataformat import Configuration, DatasetReplica, ObjectError
from common.interface.mysql import MySQL
import source.impl as sources
from common.configuration import common_config

with open(args.config) as source:
    config = Configuration(source)

LOG.info('Starting inventory update.')

group_source = sources.PhEDExGroupInfoSource(config.groups.config)
site_source = sources.PhEDExSiteInfoSource(config.sites.config)
dataset_source = sources.PhEDExDatasetInfoSource(config.datasets.config)
replica_source = sources.PhEDExReplicaInfoSource(config.replicas.config)

state_db_params = Configuration(common_config.mysql)
state_db_params.update(config.state.db_params)
app_table = MySQL(**state_db_params)

## Refresh groups and sites

LOG.info('Updating list of groups.')
for group in group_source.get_group_list():
    dynamo.update(group, check = True)

LOG.info('Updating list of sites.')
for site in site_source.get_site_list():
    dynamo.update(site, check = True)

## Get the last update timestamp

last_update = app_table.query('SELECT UNIX_TIMESTAMP(`last_update`) FROM `update_replicas_cms`')[0]
update_start = time.time()

## Fetch the full list of block replicas that were updated since updated_since.
## New datasets and blocks will be caught in the process.

LOG.info('Updating list of datasets, blocks, and replicas.')
for replica in replica_source.get_updated_replicas(last_update):
    replica_str = str(replica)

    LOG.debug('Updating %s', replica_str)

    # 0.1: pick up replicas of known groups only
    if replica.group is not None and replica.group.name not in dynamo.groups:
        LOG.debug('%s is owned by %s, which is not a tracked group.', replica_str, replica.group.name)
        continue

    # 0.2: Pick up replicas at known sites only
    try:
        site = dynamo.sites[replica.site.name]
    except KeyError:
        LOG.debug('%s is at %s, which is not a tracked site.', replica_str, replica.site.name)
        continue

    # 1: Find the dataset in the inventory

    try:
        dataset = dynamo.datasets[replica.block.dataset.name]
    except KeyError:
        # If not found, create a new dataset and inject
        LOG.info('Unknown dataset %s. Collecting information.', replica.block.dataset.name)

        dataset_tmp = dataset_source.get_dataset(replica.block.dataset.name)
        if dataset_tmp is None:
            LOG.error('Unknown dataset %s.', replica.block.dataset.name)
            continue

        dynamo.update(dataset_tmp, check = True)

        # This is the dataset that is embedded in the inventory
        dataset = dynamo.datasets[replica.block.dataset.name]

        # Inject blocks as well
        for block in dataset_tmp.blocks:
            dynamo.update(block)
    else:
        # If found, update the information (size, last_update, etc.) if necessary
        LOG.debug('Updating information for dataset %s', dataset.name)
        dynamo.update(replica.block.dataset, check = True)

    # 2: Find the block of the dataset

    block_full_name = replica.block.full_name()
    block = dataset.find_block(replica.block.name)

    if block is None:
        # If not found, create a new block and inject
        LOG.debug('Unknown block %s. Collecting information.', block_full_name)

        block_tmp = dataset_source.get_block(block_full_name, dataset)
        if block_tmp is None:
            LOG.error('Unknown block %s.', block_full_name)
            continue

        dynamo.update(block_tmp)

        # This is the block that is embedded in the inventory (`block.dataset` points to `dataset`)
        block = dataset.find_block(replica.block.name)

        dataset.size += block.size
        dataset.num_files += block.num_files

        # Update dataset information
        dynamo.update(dataset, check = True)
    else:
        # If found, update the information if necessary
        LOG.debug('Updating information for block %s', block_full_name)
        dynamo.update(replica.block, check = True)

    # 3. Find the dataset replica

    if site.find_dataset_replica(dataset) is None:
        # If not found, create a new replica and inject
        LOG.debug('Creating new replica of %s at %s', dataset.name, site.name)
        dynamo.update(DatasetReplica(dataset, site))

    # 4. Update the block replica

    LOG.debug('Updating block replica.')
    dynamo.update(replica)

## Repeat for deleted block replicas

for replica in replica_source.get_deleted_replicas(last_update):
    replica_str = str(replica)

    LOG.debug('Deleting %s', replica_str)

    # 0.1: pick up replicas of known groups only
    if replica.group is not None and replica.group.name not in dynamo.groups:
        LOG.debug('%s is owned by %s, which is not a tracked group.', replica_str, replica.group.name)
        continue

    # 0.2: Pick up replicas at known sites only
    try:
        site = dynamo.sites[replica.site.name]
    except KeyError:
        LOG.debug('%s is at %s, which is not a tracked site.', replica_str, replica.site.name)
        continue

    # 1: Find the dataset in the inventory

    try:
        dataset = dynamo.datasets[replica.block.dataset.name]
    except KeyError:
        # If not found, create a new dataset and inject
        LOG.debug('Unknown dataset %s.', dataset.name)
        continue

    # 2: Find the block of the dataset

    block_full_name = replica.block.full_name()
    block = dataset.find_block(replica.block.name)

    if block is None:
        # If not found, create a new block and inject
        LOG.debug('Unknown block %s.', block_full_name)
        continue

    # 3. Find the dataset replica

    if site.find_dataset_replica(dataset) is None:
        LOG.debug('No replica of %s at %s.', dataset.name, site.name)
        continue

    # 4. Delete the block replica

    # blockreplica.delete_from() raises a KeyError or ObjectError if
    # any of the group, site, dataset, ... is not found
    try:
        dynamo.delete(replica)
    except KeyError:
        LOG.debug('Replica not found.')
        pass
    except ObjectError:
        LOG.debug('Replica not found.')
        pass

    # 5. Delete the dataset replica if it is empty

    if len(dataset_replica.block_replicas) == 0:
        dynamo.delete(dataset_replica)

## Store the timestamp of when we started (allow 1 minute safety margin)
#app_table.query('UPDATE `update_replicas_cms` SET `last_update` = FROM_UNIXTIME(%s)', update_start - 60)

LOG.info('Inventory update completed.')
