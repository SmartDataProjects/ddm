#!/usr/bin/env python

import os
import sys
import pwd
import signal
import time
import traceback
import threading
import Queue
import logging
import logging.handlers

## Read server config (should be readable only to root)
from dynamo.dataformat import Configuration
import dynamo.core.server as main

try:
    config_path = os.environ['DYNAMO_SERVER_CONFIG']
except KeyError:
    config_path = '/etc/dynamo/server_config.json'

config = Configuration(config_path)

## Set up logging (write to stderr unless path is given)
log_level = getattr(logging, config.logging.level.upper())
log_format = '%(asctime)s:%(levelname)s:%(name)s: %(message)s'

LOG = logging.getLogger()
LOG.setLevel(log_level)
if config.logging.get('path', ''):
    log_handler = logging.handlers.RotatingFileHandler(config.logging.path + '/server.log', maxBytes = 10000000, backupCount = 100)
else:
    log_handler = logging.StreamHandler()
LOG.addHandler(log_handler)

# Print some nice logo before we start logging with the timestamp format
LOG.critical(main.BANNER)

log_handler.setFormatter(logging.Formatter(fmt = log_format))

# Logger specific for object update reports from the server
changelog = logging.getLogger('changelog')
changelog.propagate = False
changelog.setLevel(logging.INFO)
if config.logging.get('path', ''):
    log_handler = logging.handlers.RotatingFileHandler(config.logging.path + '/updates.log', maxBytes = 10000000, backupCount = 100)
else:
    log_handler = logging.StreamHandler()
changelog.addHandler(log_handler)

changelog.critical(main.BANNER)

log_handler.setFormatter(logging.Formatter(fmt = '%(asctime)s: %(message)s'))

## Set the effective user id to config.user
try:
    pwnam = pwd.getpwnam(config.user)
    os.setegid(pwnam.pw_gid)
    os.seteuid(pwnam.pw_uid)
except OSError:
    LOG.warning('Cannot switch uid to %s (%d).', config.user, pwd.getpwnam(config.user).pw_uid)

## Start the server
server = main.DynamoServer(config)

if config.applications.enabled:
    # Only the main thread can issue kill signals. We need the server to report back processes that need to be killed.
    server.kill_queue = Queue.Queue()

# Loop with server status check, update, and application execution (if enabled)
srv_thread = threading.Thread(target = server.run)
srv_thread.start()

if config.web.enabled:
    from dynamo.web.server import WebServer
    from flup.server.fcgi import WSGIServer

    web = WebServer(config.web, server)
    # Thread-based WSGI server
    WSGIServer(web.main, bindAddress = config.web.socket, umask = 0).run()

else:
    # WSGIServer intercepts INT, TERM, and HUP so we do the same here
    # Convert SIGTERM and SIGHUP into KeyboardInterrupt (SIGINT already is)
    from dynamo.utils.signaling import SignalConverter
    signal_converter = SignalConverter(logger = LOG)
    signal_converter.set(signal.SIGTERM)
    signal_converter.set(signal.SIGHUP)

    # Now just wait for the signal
    try:
        if server.kill_queue:
            while True:
                time.sleep(1)
                while True:
                    try:
                        pid, timeout = server.kill_queue.get_nowait()
                    except Queue.Empty:
                        break
                    else:
                        try:
                            os.kill(pid, signal.SIGTERM)
                        except OSError:
                            continue

                        os.waitpid(pid, timeout)

        else:
            # there's nothing to monitor - we just wait
            signal.pause()

    except KeyboardInterrupt:
        pass
    except:
        exc_type, exc, tb = sys.exc_info()
        sys.stderr.write('Traceback (most recent call last):\n')
        sys.stderr.write(''.join(traceback.format_tb(tb)) + '\n')
        sys.stderr.write('%s: %s\n' % (exc_type.__name__, str(exc)))

server.shutdown()
srv_thread.join()
