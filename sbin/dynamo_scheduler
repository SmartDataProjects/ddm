#!/usr/bin/env python

import os
import sys
import logging
import logging.handlers
import time
import re
import shutil
import hashlib
import multiprocessing
import signal

from argparse import ArgumentParser

parser = ArgumentParser(description = 'Schedule routine sequences of Dynamo executables.')
parser.add_argument('sequence', metavar = 'PATH', help = 'Sequence file.')
parser.add_argument('--config', '-c', metavar = 'CONFIG', dest = 'config', required = True, help = 'Configuration JSON.')

args = parser.parse_args()
sys.argv = []

## Load the configuration
from dataformat.configuration import Configuration

config = Configuration(args.config)

## Set up logging (write to stderr unless path is given)
log_level = getattr(logging, config.logging.level.upper())
log_format = '%(asctime)s:%(levelname)s:%(name)s: %(message)s'

LOG = logging.getLogger()
LOG.setLevel(log_level)
if config.logging.get('path', ''):
    log_handler = logging.handlers.RotatingFileHandler(config.logging.path + '/scheduler.log', maxBytes = 1000000, backupCount = 100)
else:
    log_handler = logging.StreamHandler()
LOG.addHandler(log_handler)

# Print some nice logo before we start logging with the timestamp format
LOG.critical('''
+++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++ DYNAMO SCHEDULER +++++++++++++++
++++++++++++++  v2.0  +++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++++++++++
''')

log_handler.setFormatter(logging.Formatter(fmt = log_format))

## Create the registry
from core.registry import DynamoRegistry

registry = DynamoRegistry(config.registry)

result = registry.backend.query('SELECT `id` FROM `users` WHERE `name` = %s', config.user)
if len(result) == 0:
    raise RuntimeError('User %s not found' % config.user)

user_id = result[0]

## Load the sequences
EXECUTE, WAIT, TERMINATE = range(3)

executables = {} # {title: (exec path, write_enabled)}
sequences = {} # {name: sequence}
sequence = []

with open(args.sequence) as source:
    for line in source:
        line = line.strip()
        if not line or line.startswith('#'):
            continue

        LOG.debug(line)

        # Executable definitions
        matches = re.match('{(\S+)}\s*=\s*(\S+)', line)
        if matches:
            title = matches.group(1)
            executable = matches.group(2)

            # Replace environment variables
            matches = re.findall('\$\(([^\)]+)\)', executable)
            for match in matches:
                executable = executable.replace('$(%s)' % match, os.environ[match])

            # If the executable is write-enabled, we automatically request write access
            try:
                with open(executable) as source:
                    checksum = hashlib.md5(source.read()).hexdigest()
            except:
                sys.stderr.write('Could not open executable %s.\n', executable)
                sys.exit(1)

            write_enabled = False
            sql = 'SELECT `user_id` FROM `authorized_executables` WHERE `title` = %s AND `checksum` = UNHEX(%s)'
            for auth_user_id in registry.backend.query(sql, title, checksum):
                if auth_user_id == 0 or auth_user_id == user_id:
                    write_enabled = True

            LOG.debug('Define executable %s = %s (write enabled: %d)', title, executable, write_enabled)

            executables[title] = (executable, write_enabled)
            continue

        matches = re.match('\[SEQUENCE\s(\S+)\]', line)
        if matches:
            # Sequence header
            LOG.debug('New sequence %s', matches.group(1))
            sequence = sequences[matches.group(1)] = []
            continue

        matches = re.match('{(\S+)}\s*(.*)', line)
        if matches:
            title = matches.group(1)
            arguments = matches.group(2)

            # Replace environment variables
            matches = re.findall('\$\(([^\)]+)\)', arguments)
            for match in matches:
                arguments = arguments.replace('$(%s)' % match, os.environ[match])

            LOG.debug('Execute %s %s', title, arguments)

            sequence.append((EXECUTE, title, arguments))
            continue

        matches = re.match('WAIT\s+(.*)', line)
        if matches:
            try:
                sleep_time = eval(matches.group(1))
                if type(sleep_time) not in [int, float]:
                    raise RuntimeError()
            except:
                sys.stderr.write('Wait time %s is not a numerical expression.\n')
                sys.exit(1)

            LOG.debug('Wait for %d seconds', sleep_time)
            sequence.append((WAIT, sleep_time))
            continue

        if line == 'TERMINATE':
            sequence.append([TERMINATE])

if len(sequences) == 0:
    sys.stderr.write('No sequence was loaded.\n')
    sys.exit(1)

## Create the executable directory and copy the scripts over
for name, sequence in sequences.iteritems():
    work_dir = config.scheduler_path + '/' + name
    try:
        shutil.rmtree(work_dir)
    except OSError:
        pass
    os.makedirs(work_dir)

    with open(work_dir + '/log.out', 'w'):
        pass

    with open(work_dir + '/log.err', 'w'):
        pass

    for action in sequence:
        if action[0] == EXECUTE:
            title = action[1]

            path = '%s/%s' % (work_dir, title)
            if os.path.exists(path):
                # This executable is used multiple times in the sequence
                continue

            executable, _ = executables[title]

            os.makedirs(path)
            shutil.copy(executable, path + '/exec.py')

            # Make symlinks from subdir/_std(out|err) to log.(out|err)
            os.symlink(work_dir + '/log.out', path + '/_stdout')
            os.symlink(work_dir + '/log.err', path + '/_stderr')

LOG.info('Created working directories under %s.', config.scheduler_path)

def loop_sequence(sequence_name, sequence, user_id, config):
    ## Ignore SIGINT - see note above proc.terminate() at the end of the file
    ## We will react to SIGTERM by raising KeyboardInterrupt
    from utils.signaling import SignalConverter

    signal.signal(signal.SIGINT, signal.SIG_IGN)

    ## Use the same logger as the main process, but with a different format
    LOG.info('Sequence %s (PID: %d)', sequence_name, os.getpid())

    log_format = '%(asctime)s:%(levelname)s:{sequence} ({pid}): %(message)s'.format(sequence = sequence_name, pid = os.getpid())
    LOG.handlers[0].setFormatter(logging.Formatter(fmt = log_format))

    ## Create a registry handle - we'll be submitting execution requests from the backend
    registry = DynamoRegistry(config.registry)

    ## SQL templates
    insert_sql = 'INSERT INTO `action` (`user_id`, `write_request`, `title`, `path`, `args`)'
    insert_sql += ' VALUES ({user_id}, %s, %s, %s, %s)'.format(user_id = user_id)

    poll_sql = 'SELECT `status` FROM `action` WHERE `id` = %s'

    work_dir = config.scheduler_path + '/' + sequence_name
    title = ''
    task_id = 0

    try:
        ## Start an infinite loop
        while True:
            for action in sequence:
                if action[0] == EXECUTE:
                    title, arguments = action[1:]
                    executable, write_enabled = executables[title]
    
                    LOG.info('Starting %s', title)
                    LOG.info('Command: %s %s', executable, arguments)
    
                    with open(work_dir + '/log.out', 'a') as out:
                        out.write('------------------------ ' + title + ' ------------------------\n')
                        out.write('%s %s\n\n' % (executable, arguments))
    
                    with open(work_dir + '/log.err', 'a') as out:
                        out.write('------------------------ ' + title + ' ------------------------\n\n')
    
                    # Submit the task. Actual executable is in work_dir/title
                    path = '%s/%s' % (work_dir, title)
                    task_id = registry.backend.query(insert_sql, write_enabled, title, path, arguments)
    
                    # Poll for task completion
                    while True:
                        time.sleep(1)
                        result = registry.backend.query(poll_sql, task_id)
                        if len(result) == 0:
                            # len(result) == 0 -> entry disappeared!?
                            status = 'unknown'
                            break
                        else:
                            status = result[0]
                            if status not in ['new', 'run']:
                                break

                    task_id = 0
    
                    try:
                        with open(work_dir + '/log.out', 'a') as out:
                            out.write('\n')
                    except:
                        pass
    
                    try:
                        with open(work_dir + '/log.err', 'a') as out:
                            out.write('\n')
                    except:
                        pass
    
                    LOG.info('Finished %s with (status: %s)\n', title, status)
    
                elif action[0] == WAIT:
                    LOG.info('Sleeping for %d seconds.\n', action[1])
                    time.sleep(action[1])
    
                elif action[0] == TERMINATE:
                    LOG.info('Terminating sequence.')
                    break
    
            else:
                # Passed through the sequence without breaking
                continue
    
            # There was a break -> sequence terminated
            break

    except KeyboardInterrupt:
        if task_id != 0:
            # Task aborted - update the status from the backend so Dynamo picks it up
            registry.backend.query('UPDATE `action` SET `status` = \'killed\' WHERE `id` = %s', task_id)
            LOG.info('Process interrupted. aborting task %s.', title)
        else:
            LOG.info('Process interrupted.')


## Prepare to catch a kill
from utils.signaling import SignalConverter
signal_converter = SignalConverter(logger = LOG)
signal_converter.set(signal.SIGTERM)

try:
    ## Create a process for each sequence and start as daemons
    processes = []
    for name, sequence in sequences.iteritems():
        proc = multiprocessing.Process(target = loop_sequence, name = name, args = (name, sequence, user_id, config))
        proc.daemon = True
        proc.start()
        LOG.info('Started sequence %s.', name)
        
        processes.append(proc)

    ## Sleep indefinitely
    for proc in processes:
        proc.join()

except KeyboardInterrupt:
    LOG.info('Scheduler terminated.')

except:
    LOG.error('Exception in scheduler. Terminating all sequences.')
    raise

finally:
    # This can be a Ctrl+C or a kill.
    # Ctrl+C will pass SIGINT to all child processes (if this process is the head of the
    # foreground process group). In this case calling terminate() will duplicate signals
    # in the child. Child processes have to always ignore SIGINT and be killed only from
    # SIGTERM sent by the line below.
    for proc in processes:
        proc.terminate()
        proc.join(2)

LOG.info('All sequences completed.')
