#!/usr/bin/env python

import os
import sys
import pwd
import logging
import logging.handlers
import time
import re
import shutil
import hashlib
import multiprocessing
import signal
import smtplib
import socket
from email.mime.text import MIMEText

def loop_sequence(sequence_name, work_dir_base, config, sequence):
    ## Ignore SIGINT - see note above proc.terminate() at the end of the file
    ## We will react to SIGTERM by raising KeyboardInterrupt
    from dynamo.utils.signaling import SignalConverter

    signal.signal(signal.SIGINT, signal.SIG_IGN)

    ## Use the same logger as the main process, but with a different format
    LOG.info('Sequence %s (PID: %d)', sequence_name, os.getpid())

    log_format = '%(asctime)s:%(levelname)s:{sequence} ({pid}): %(message)s'.format(sequence = sequence_name, pid = os.getpid())
    LOG.handlers[0].setFormatter(logging.Formatter(fmt = log_format))

    ## Re-init the server manager (cannot share database connections among processes)
    manager = ServerManager(config.manager)

    work_dir = work_dir_base + '/' + sequence_name
    title = ''
    task_id = 0

    action_texts = []
    for action in sequence:
        if action[0] == EXECUTE:
            action_texts.append(action[1])
        elif action[0] == WAIT:
            action_texts.append('WAIT(%d)' % action[1])
        elif action[0] == TERMINATE:
            action_texts.append('TERMINATE')

    try:
        ## Start an infinite loop
        while True:
            repeat = True

            ia = 0
            while ia != len(sequence):
                action = sequence[ia]

                current_action_texts = list(action_texts)
                current_action_texts[ia] = '*' + action_texts[ia]
                sequence_text = ' '.join(current_action_texts)
                LOG.info('Sequence %s (PID: %d): %s', sequence_name, os.getpid(), sequence_text)

                if action[0] == EXECUTE:
                    title, arguments, criticality, write_request = action[1:]
                    application = applications[title]
    
                    LOG.info('Starting %s', title)
                    LOG.info('Command: %s %s', application, arguments)
    
                    with open(work_dir + '/log.out', 'a') as out:
                        out.write('------------------------ ' + title + ' ------------------------\n')
                        out.write('%s %s\n\n' % (application, arguments))
    
                    with open(work_dir + '/log.err', 'a') as out:
                        out.write('------------------------ ' + title + ' ------------------------\n\n')
    
                    # Submit the task. Actual application is in work_dir/title
                    path = '%s/%s' % (work_dir, title)
                    
                    task_id = manager.master.schedule_application(title, path, arguments, args.auth_user, socket.gethostname(), write_request)
    
                    # Poll for task completion
                    while True:
                        time.sleep(1)
                        status = manager.get_application_status(task_id)
                        if status not in [ServerManager.APP_NEW, ServerManager.APP_RUN]:
                            break

                    task_id = 0
    
                    try:
                        with open(work_dir + '/log.out', 'a') as out:
                            out.write('\n')
                    except:
                        pass
    
                    try:
                        with open(work_dir + '/log.err', 'a') as out:
                            out.write('\n')
                    except:
                        pass
    
                    LOG.info('Finished %s with (status: %s)', title, ServerManager.application_status_name(status))

                    if criticality != PASS and status != ServerManager.APP_DONE:
                        msg = MIMEText('Message from dynamo-scheduled@%s:\nApplication %s of sequence %s failed.' % \
                            (socket.gethostname(), title, sequence_name))

                        msg['Subject'] = '[Dynamo Scheduler] failure notice'
                        msg['From'] = 'dynamo@' + socket.gethostname()
                        msg['To'] = config.notification_recipient

                        mailserv = smtplib.SMTP('localhost')
                        mailserv.sendmail(msg['From'], [msg['To']], msg.as_string())
                        mailserv.quit()

                        if criticality == REPEAT_SEQ:
                            LOG.error('Critical application %s failed. Restarting sequence %s.', title, sequence_name)
                            break
                        elif criticality == REPEAT_LINE:
                            LOG.error('Critical application %s failed. Restarting application %s.', title, title)
                            continue

                elif action[0] == WAIT:
                    LOG.info('Sleeping for %d seconds.', action[1])
                    time.sleep(action[1])
    
                elif action[0] == TERMINATE:
                    LOG.info('Terminating sequence.')
                    repeat = False
                    break

                ia += 1
    
            if not repeat:
                break

    except KeyboardInterrupt:
        if task_id != 0:
            # Task aborted - update the status from the backend so Dynamo picks it up
            manager.set_application_status(task_id, ServerManager.APP_KILLED)
            LOG.info('Process interrupted. aborting task %s.', title)
        else:
            LOG.info('Process interrupted.')

if __name__ == '__main__':
    
    from argparse import ArgumentParser
    
    parser = ArgumentParser(description = 'Schedule routine sequences of Dynamo applications.')
    parser.add_argument('sequence', metavar = 'PATH', help = 'Sequence file.')
    parser.add_argument('work_dir', metavar = 'PATH', help = 'Work area.')
    parser.add_argument('auth_user', metavar = 'USER', help = 'Application user name.')
    
    args = parser.parse_args()
    sys.argv = []
    
    ## Load the configuration
    from dynamo.dataformat.configuration import Configuration
    
    try:
        config_path = os.environ['DYNAMO_SERVER_CONFIG']
    except KeyError:
        config_path = '/etc/dynamo/server_config.json'
    
    config = Configuration(config_path)
    
    ## Set up logging (write to stderr unless path is given)
    log_level = getattr(logging, config.logging.level.upper())
    log_format = '%(asctime)s:%(levelname)s:%(name)s: %(message)s'
    
    LOG = logging.getLogger()
    LOG.setLevel(log_level)
    if config.logging.get('path', ''):
        log_handler = logging.handlers.RotatingFileHandler(config.logging.path + '/scheduler.log', maxBytes = 1000000, backupCount = 100)
    else:
        log_handler = logging.StreamHandler()
    LOG.addHandler(log_handler)
    
    # Print some nice logo before we start logging with the timestamp format
    LOG.critical('''
    +++++++++++++++++++++++++++++++++++++++++++++++
    ++++++++++++++ DYNAMO SCHEDULER +++++++++++++++
    ++++++++++++++  v2.0  +++++++++++++++++++++++++
    +++++++++++++++++++++++++++++++++++++++++++++++
    ''')
    
    log_handler.setFormatter(logging.Formatter(fmt = log_format))
    
    ## Set the effective user id to config.user
    try:
        os.setuid(pwd.getpwnam(config.user).pw_uid)
    except OSError:
        LOG.warning('Cannot switch uid to %s (%d).', config.user, pwd.getpwnam(config.user).pw_uid)
    
    ## Create the server manager
    from dynamo.core.manager import ServerManager
    manager = ServerManager(config.manager)
    
    ## Load the sequences
    # commands
    EXECUTE, WAIT, TERMINATE = range(3)
    # criticality
    REPEAT_SEQ, REPEAT_LINE, PASS = range(3)
    
    applications = {} # {title: exec path}
    authorized_applications = set() # set of titles
    sequences = {} # {name: sequence}
    sequence = []
    
    with open(args.sequence) as source:
        iline = -1
        for line in source:
            iline += 1
    
            line = line.strip()
            if not line or line.startswith('#'):
                continue
    
            LOG.debug(line)
    
            # Application definitions
            # {title} = path  ...  This application cannot write
            # <title> = path  ...  This application can be used to write
            matches = re.match('({\S+}|<\S+>)\s*=\s*(\S+)', line)
            if matches:
                enclosed_title = matches.group(1)
                title = enclosed_title[1:-1]
                write_enabled = (enclosed_title[0] == '<')
                application = matches.group(2)
    
                # Replace environment variables
                matches = re.findall('\$\(([^\)]+)\)', application)
                for match in matches:
                    application = application.replace('$(%s)' % match, os.environ[match])
    
                if write_enabled and not manager.check_write_auth(title, args.auth_user, os.path.dirname(application), os.path.basename(application)):
                    LOG.error('Application %s (%s) is not authorized for server write operation (line %d).', title, application, iline)
                    sys.exit(1)
    
                LOG.debug('Define application %s = %s (write enabled: %d) (line %d)', title, application, write_enabled, iline)
    
                applications[title] = application
                if write_enabled:
                    authorized_applications.add(title)
                
                continue
    
            # Sequence definitions
            # [SEQUENCE title]
            matches = re.match('\[SEQUENCE\s(\S+)\]', line)
            if matches:
                # Sequence header
                LOG.debug('New sequence %s (line %d)', matches.group(1), iline)
                sequence = sequences[matches.group(1)] = []
                continue
    
            # Sequence application step definitions
            # {title} options  ...  Read-only execution
            # <title> options  ...  Write-request execution
            matches = re.match('(\^|\&|\|) +({\S+}|<\S+>)\s*(.*)', line)
            if matches:
                if matches.group(1) == '^':
                    criticality = REPEAT_SEQ
                elif matches.group(1) == '&':
                    criticality = REPEAT_LINE
                else:
                    criticality = PASS
    
                enclosed_title = matches.group(2)
                title = enclosed_title[1:-1]
                write_request = (enclosed_title[0] == '<')
                arguments = matches.group(3)
    
                if write_request and title not in authorized_applications:
                    LOG.error('Application %s is not write-enabled (line %d).', iline)
    
                # Replace environment variables
                matches = re.findall('\$\(([^\)]+)\)', arguments)
                for match in matches:
                    arguments = arguments.replace('$(%s)' % match, os.environ[match])
    
                LOG.debug('Execute %s %s (line %d)', title, arguments, iline)
    
                sequence.append((EXECUTE, title, arguments, criticality, write_request))
                continue
    
            matches = re.match('WAIT\s+(.*)', line)
            if matches:
                try:
                    sleep_time = eval(matches.group(1))
                    if type(sleep_time) not in [int, float]:
                        raise RuntimeError()
                except:
                    LOG.error('Wait time %s is not a numerical expression (line %d).', matches.group(1), iline)
                    sys.exit(1)
    
                LOG.debug('Wait for %d seconds (line %d)', sleep_time, iline)
                sequence.append((WAIT, sleep_time))
                continue
    
            if line == 'TERMINATE':
                sequence.append([TERMINATE])
    
    if len(sequences) == 0:
        LOG.error('No sequence was loaded.')
        sys.exit(1)
    
    ## Create the application directory and copy the scripts over
    for name, sequence in sequences.iteritems():
        work_dir = args.work_dir + '/' + name
        try:
            shutil.rmtree(work_dir)
        except OSError:
            pass
        os.makedirs(work_dir)
        os.chmod(work_dir, 0777)
    
        with open(work_dir + '/log.out', 'w'):
            pass
    
        os.chmod(work_dir + '/log.out', 0666)
    
        with open(work_dir + '/log.err', 'w'):
            pass
    
        os.chmod(work_dir + '/log.err', 0666)
    
        for action in sequence:
            if action[0] == EXECUTE:
                title = action[1]
    
                path = '%s/%s' % (work_dir, title)
                if os.path.exists(path):
                    # This application is used multiple times in the sequence
                    continue
    
                application = applications[title]
    
                os.makedirs(path)
                shutil.copy(application, path + '/exec.py')
    
                # Make symlinks from subdir/_std(out|err) to log.(out|err)
                os.symlink(work_dir + '/log.out', path + '/_stdout')
                os.symlink(work_dir + '/log.err', path + '/_stderr')
    
    LOG.info('Created working directories under %s.', args.work_dir)
    
    ## Prepare to catch a kill
    from dynamo.utils.signaling import SignalConverter
    signal_converter = SignalConverter(logger = LOG)
    signal_converter.set(signal.SIGTERM)
    
    try:
        ## Create a process for each sequence and start as daemons
        processes = []
        for name, sequence in sequences.iteritems():
            proc = multiprocessing.Process(target = loop_sequence, name = name, args = (name, args.work_dir, config, sequence))
            proc.daemon = True
            proc.start()
            LOG.info('Started sequence %s.', name)
            
            processes.append(proc)
    
        ## Sleep indefinitely
        for proc in processes:
            proc.join()
    
    except KeyboardInterrupt:
        LOG.info('Scheduler terminated.')
    
    except:
        LOG.error('Exception in scheduler. Terminating all sequences.')
        raise
    
    finally:
        # This can be a Ctrl+C or a kill.
        # Ctrl+C will pass SIGINT to all child processes (if this process is the head of the
        # foreground process group). In this case calling terminate() will duplicate signals
        # in the child. Child processes have to always ignore SIGINT and be killed only from
        # SIGTERM sent by the line below.
        for proc in processes:
            proc.terminate()
            proc.join(2)
    
    LOG.info('All sequences completed.')
