#!/usr/bin/env python

import os
import sys
import httplib
import urllib
import urllib2
import ssl
import socket
import mimetools
import threading
import time
import json

from argparse import ArgumentParser

parser = ArgumentParser(description = 'Submit one dynamo executable task.')
parser.add_argument('cmd', metavar = 'CMD', help = 'Executable command')
parser.add_argument('--title', '-t', metavar = 'TITLE', dest = 'title', help = 'Executable title.')
parser.add_argument('--asynchronous', '-A', action = 'store_true', dest = 'asynch', help = 'Do not wait for the executable to complete.')
parser.add_argument('--write-request', '-W', action = 'store_true', dest = 'write_request', help = 'Request write access.')
parser.add_argument('--work-dir', '-d', metavar = 'PATH', dest = 'workdir', help = 'Working directory. If not set, use a temporary directory.')

args = parser.parse_args()
sys.argv = []

## If synchronous execution + work directory provided, wipe out the logs
if not args.asynch:
    # check server running?

    if args.workdir:
        try:
            os.makedirs(args.workdir)
        except OSError:
            pass
        os.chmod(args.workdir, 0777)
        with open(args.workdir + '/_stdout', 'w'):
            pass
        with open(args.workdir + '/_stderr', 'w'):
            pass

## Submit an executable through the registry front end.

class HTTPSCertKeyHandler(urllib2.HTTPSHandler):
    """
    HTTPS handler authenticating by x509 user key and certificate.
    """

    def __init__(self):
        urllib2.HTTPSHandler.__init__(self)
        try:
            self.key = os.environ['X509_USER_PROXY']
        except KeyError:
            self.key = '/tmp/x509up_u%d' % os.geteuid()

        if not os.path.exists(self.key):
            LOG.error('HTTPSCertKeyHandler requires an X509 proxy in either')
            LOG.error('1. Environment variable X509_USER_PROXY')
            LOG.error('2. /tmp/x509up_u(uid)')
            raise ConfigurationError('X509 proxy missing')

        self.cert = self.key

        # Switch off server cert verification if the switch is available
        try:
            ssl._https_verify_certificates(False)
        except AttributeError:
            # If the switch does not exist, hope urllib2 doesn't verify the server by default
            pass

    def https_open(self, req):
        return self.do_open(self.create_connection, req)

    def create_connection(self, host, timeout = 300):
        return httplib.HTTPSConnection(host, key_file = self.key, cert_file = self.cert)

cmds = args.cmd.split()
executable = cmds[0]
with open(executable) as source:
    file_content = source.read()

boundary = mimetools.choose_boundary()

# The executable file
data = [
    '--' + boundary,
    'Content-Disposition: file; name="file"; filename="exec.py"',
    'Content-Type: text/plain',
    '',
    file_content
]

# Options
def add_field(name, field_data):
    global data

    data += [
        '--' + boundary,
        'Content-Disposition: form-data; name="%s"' % name,
        '',
        field_data
    ]

if args.title:
    add_field('title', args.title)

if len(cmds) > 1:
    add_field('args', ' '.join(cmds[1:]))

if args.write_request:
    add_field('write', '1')

if args.workdir:
    add_field('workdir', args.workdir)

data += [
    '--' + boundary + '--'
]

body = '\r\n'.join(data)

try:
    server_host = os.environ['DYNAMO_SERVER_HOST']
except KeyError:
    server_host = socket.gethostname()

request = urllib2.Request('https://%s/registry/application' % server_host)
request.add_header('Content-type', 'multipart/form-data; boundary=%s' % boundary)
request.add_header('Content-length', len(body))
request.add_data(body)

# Now submit
try:
    opener = urllib2.build_opener(HTTPSCertKeyHandler())
    response = opener.open(request)
    content = response.read()
    result = json.loads(content)

except urllib2.HTTPError as err:
    sys.stderr.write('Server responded: Error %d\n' % err.code)
    sys.stderr.write(str(err) + '\n')
    sys.stderr.write(err.read())
    sys.exit(1)

## Print out the response
task_info = result['data'][0]
task_id = task_info['taskid']
path = task_info['path']

print 'task id:', task_id
print 'path:', path

if not args.asynch:
    ## Synchronous execution: dynamo_exec will wait until process completion

    def tail_follow(source_path, stream, lock, stop_reading):
        ## tail -f emulation
        while True:
            if os.path.exists(source_path):
                break

            if stop_reading.is_set():
                return

            time.sleep(0.5)

        with open(source_path) as source:
            lock.acquire()
            while True:
                if stop_reading.is_set():
                    lock.release()
                    return

                pos = source.tell()
                line = source.readline()
                if not line:
                    source.seek(pos)
                    lock.release()
                    time.sleep(0.5)
                    lock.acquire()
                else:
                    stream.write(line)

    stop_reading = threading.Event()
    lock = threading.Lock()
    stdout_thread = threading.Thread(target = tail_follow, name = 'stdout', args = (path + '/_stdout', sys.stdout, lock, stop_reading))
    stderr_thread = threading.Thread(target = tail_follow, name = 'stderr', args = (path + '/_stderr', sys.stderr, lock, stop_reading))
    stdout_thread.start()
    stderr_thread.start()

    try:
        return_code = 0

        while True:
            opener = urllib2.build_opener(HTTPSCertKeyHandler())
            request = urllib2.Request('https://t3desk007.mit.edu/registry/application?taskid=%d' % task_info['taskid'])
            request.add_header('Accept', 'application/json')
            response = opener.open(request)
            content = response.read()
            
            result = json.loads(content)

            status = result['data'][0]['status']
            if status not in ('new', 'run'):
                if status != 'done':
                    return_code = 1

                stop_reading.set()
                stdout_thread.join()
                stderr_thread.join()
                break

            time.sleep(3)

    except KeyboardInterrupt:
        stop_reading.set()
        stdout_thread.join()
        stderr_thread.join()

        while True:
            sys.stdout.write('Kill task? [y/n]: ')
            sys.stdout.flush()
            response = sys.stdin.readline().strip()
            if response == 'y':
                opener = urllib2.build_opener(HTTPSCertKeyHandler())
                request = urllib2.Request('https://t3desk007.mit.edu/registry/application?action=kill&taskid=%d' % task_info['taskid'])
                request.add_header('Accept', 'application/json')
                response = opener.open(request)
                content = response.read()

                result = json.loads(content)
                sys.stdout.write('\n' + result['data'][0]['message'] + '\n')

            elif respose != 'n':
                sys.stdout.write('Please answer in y/n.\n')
                continue

            break

    except:
        stop_reading.set()
        stdout_thread.join()
        stderr_thread.join()

        sys.stderr.write('Caught exception while waiting for task to complete.\n')
        return_code = 2

    sys.exit(return_code)
