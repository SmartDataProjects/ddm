#!/usr/bin/env python

import os
import sys
import httplib
import urllib
import urllib2
import mimetools
import threading
import time
import json

from argparse import ArgumentParser

parser = ArgumentParser(description = 'Submit one dynamo executable task.')
parser.add_argument('cmd', metavar = 'CMD', help = 'Executable command')
parser.add_argument('--title', '-t', metavar = 'TITLE', dest = 'title', help = 'Executable title.')
parser.add_argument('--synchronous', '-S', action = 'store_true', dest = 'synch', help = 'Wait for the executable to complete.')
parser.add_argument('--write-request', '-W', action = 'store_true', dest = 'write_request', help = 'Request write access.')
parser.add_argument('--work-dir', '-d', metavar = 'PATH', dest = 'workdir', help = 'Working directory. If not set, use a temporary directory.')

args = parser.parse_args()
sys.argv = []

## If synchronous execution + work directory provided, wipe out the logs
if args.synch and args.workdir:
    with open(args.workdir + '/_stdout', 'w'):
        pass
    with open(args.workdir + '/_stderr', 'w'):
        pass

## Submit an executable through the registry front end.

class HTTPSCertKeyHandler(urllib2.HTTPSHandler):
    """
    HTTPS handler authenticating by x509 user key and certificate.
    """

    def __init__(self):
        urllib2.HTTPSHandler.__init__(self)
        self.key = os.environ['X509_USER_PROXY']
        self.cert = os.environ['X509_USER_PROXY']

    def https_open(self, req):
        return self.do_open(self.create_connection, req)

    def create_connection(self, host, timeout = 300):
        return httplib.HTTPSConnection(host, key_file = self.key, cert_file = self.cert)

cmds = args.cmd.split()
executable = cmds[0]
with open(executable) as source:
    file_content = source.read()

boundary = mimetools.choose_boundary()

# The executable file
data = [
    '--' + boundary,
    'Content-Disposition: file; name="file"; filename="exec.py"',
    'Content-Type: text/plain',
    '',
    file_content
]

# Options
def add_field(name, field_data):
    global data

    data += [
        '--' + boundary,
        'Content-Disposition: form-data; name="%s"' % name,
        '',
        field_data
    ]

if args.title:
    add_field('title', args.title)

if len(cmds) > 1:
    add_field('args', ' '.join(cmds[1:]))

if args.write_request:
    add_field('write', '1')

if args.workdir:
    add_field('workdir', args.workdir)

data += [
    '--' + boundary + '--'
]

body = '\r\n'.join(data)

request = urllib2.Request('https://t3desk007.mit.edu/registry/application')
request.add_header('Content-type', 'multipart/form-data; boundary=%s' % boundary)
request.add_header('Content-length', len(body))
request.add_data(body)

# Now submit
try:
    opener = urllib2.build_opener(HTTPSCertKeyHandler())
    response = opener.open(request)
    content = response.read()
    result = json.loads(content)

except urllib2.HTTPError as err:
    sys.stderr.write('Server responded: Error %d\n' % err.code)
    sys.stderr.write(str(err) + '\n')
    sys.stderr.write(err.read())
    sys.exit(1)

## Print out the response
task_info = result['data'][0]
task_id = task_info['taskid']
path = task_info['path']

print 'task id:', task_id
print 'path:', path

if args.synch:
    ## Synchronous execution: dynamo_exec will wait until process completion

    def tail_follow(source_path, stream, event):
        ## tail -f emulation
        while True:
            if not os.path.exists(source_path):
                time.sleep(0.5)
                if event.is_set():
                    return

                continue

            with open(source_path) as source:
                while True:
                    if event.is_set():
                        return

                    pos = source.tell()
                    line = source.readline()
                    if not line:
                        source.seek(pos)
                        time.sleep(0.5)
                    else:
                        stream.write(line)

    stop_reading = threading.Event()
    stdout_thread = threading.Thread(target = tail_follow, name = 'stdout', args = (path + '/_stdout', sys.stdout, stop_reading))
    stderr_thread = threading.Thread(target = tail_follow, name = 'stderr', args = (path + '/_stderr', sys.stderr, stop_reading))
    stdout_thread.daemon = True
    stderr_thread.daemon = True
    stdout_thread.start()
    stderr_thread.start()

    try:
        return_code = 0

        while True:
            opener = urllib2.build_opener(HTTPSCertKeyHandler())
            request = urllib2.Request('https://t3desk007.mit.edu/registry/application?taskid=%d' % task_info['taskid'])
            request.add_header('Accept', 'application/json')
            response = opener.open(request)
            content = response.read()
            
            result = json.loads(content)

            status = result['data'][0]['status']
            if status not in ('new', 'run'):
                if status != 'done':
                    return_code = 1

                stop_reading.set()
                stdout_thread.join()
                stderr_thread.join()
                break

            time.sleep(3)

    except KeyboardInterrupt:
        stop_reading.set()
        stdout_thread.join()
        stderr_thread.join()

        while True:
            sys.stdout.write('Kill task? [y/n]: ')
            sys.stdout.flush()
            response = sys.stdin.readline().strip()
            if response == 'y':
                opener = urllib2.build_opener(HTTPSCertKeyHandler())
                request = urllib2.Request('https://t3desk007.mit.edu/registry/application?action=kill&taskid=%d' % task_info['taskid'])
                request.add_header('Accept', 'application/json')
                response = opener.open(request)
                content = response.read()

                result = json.loads(content)
                sys.stdout.write('\n' + result['data'][0]['message'] + '\n')

            elif respose != 'n':
                sys.stdout.write('Please answer in y/n.\n')
                continue

            break

    except:
        stop_reading.set()
        stdout_thread.join()
        stderr_thread.join()

        sys.stderr.write('Caught exception while waiting for task to complete.\n')
        return_code = 2

    sys.exit(return_code)
